<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Tournoi Baby-Foot — Tout-en-un</title>
<style>
  body{font-family:system-ui,Arial,Helvetica,sans-serif;margin:14px;background:#f3f7fb;color:#0b1a2b}
  .wrap{max-width:980px;margin:0 auto}
  h1{text-align:center;color:#0b66c2;margin-bottom:8px}
  .card{background:#fff;border-radius:8px;padding:14px;margin:12px 0;box-shadow:0 2px 8px rgba(0,0,0,0.06)}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:8px}
  input,select,button{padding:8px;border-radius:6px;border:1px solid #cbd5e1}
  button{cursor:pointer;background:#2563eb;color:white;border:none}
  button.warn{background:#f59e0b;color:#111}
  button.danger{background:#dc2626}
  .muted{color:#64748b;font-size:13px}
  .pill{display:inline-block;padding:6px 10px;border-radius:999px;background:#eef2ff;margin:4px;border:1px solid #c7d2fe}
  .match{border:1px solid #e2e8f0;padding:10px;border-radius:6px;margin:8px 0;background:#ffffff}
  .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:#e6eef8;margin-right:8px;font-size:12px}
  .help{font-size:13px;color:#475569}
  table{width:100%;border-collapse:collapse;margin-top:8px}
  th,td{border:1px solid #e2e8f0;padding:6px;text-align:center}
  th{background:#f8fafc}
  pre{background:#f1f5f9;padding:8px;border-radius:6px;max-height:260px;overflow:auto}
  @media(max-width:600px){ .row{flex-direction:column;align-items:stretch} }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Tournoi Baby-Foot — Qualifs & Finale 2v2</h1>

    <section class="card">
      <h2>1) Inscriptions</h2>
      <div class="row">
        <input id="playerName" placeholder="Nom du joueur" />
        <select id="playerRole"><option>Attaquant</option><option>Défenseur</option><option>Polyvalent</option></select>
        <button id="btnAdd">Ajouter</button>
        <button id="btnReset" class="danger">Réinitialiser tout</button>
      </div>
      <div id="playersList" class="muted">Aucun joueur</div>
    </section>

    <section class="card">
      <h2>2) Qualifications — DYP (2 vs 2)</h2>
      <div class="row">
        <button id="btnNewRound">Nouvelle manche</button>
        <span id="roundInfo" class="muted"></span>
      </div>
      <div id="qualifMatches"></div>

      <h3>Classement</h3>
      <div id="ranking"></div>

      <h3>Historique Qualifications</h3>
      <div id="qualifHistory" class="muted"></div>
    </section>

    <section class="card">
      <h2>3) Phase finale — Double élimination (2 vs 2)</h2>
      <div class="row">
        <label>Nombre de qualifiés:
          <input id="finalCount" type="number" value="8" min="4" step="4" style="width:90px;margin-left:6px">
        </label>
        <button id="btnStartFinals" style="background:#16a34a">Démarrer phase finale</button>
        <button id="btnForceNext" style="background:#f59e0b">Forcer avancée</button>
        <button id="btnExport" style="background:#10b981">Exporter historique</button>
      </div>
      <div class="help">Étiquette : <b>[WB Rn - Match m]</b> = Winners; <b>[LB Rn - Match m]</b> = Losers. Valide tous les matchs d'un round pour créer automatiquement le round suivant.</div>
      <div id="finalsArea"></div>

      <h3>Historique Phase Finale</h3>
      <div id="finalsHistory" class="muted"></div>
    </section>

    <section class="card">
      <h2>Debug (erreurs & état interne)</h2>
      <div class="muted">Les erreurs JS s'afficheront ici si quelque chose plante.</div>
      <pre id="debugFinals">--</pre>
    </section>
  </div>

<script>
// ---------- Global error catcher: affiche erreurs dans Debug Finals ----------
window.onerror = function(message, source, line, col, err){
  const elDbg = document.getElementById('debugFinals');
  if(elDbg) elDbg.textContent = `${message} — ${source}:${line}:${col}\n${err && err.stack ? err.stack : ''}`;
  console.error(message, source, line, col, err);
  return false;
};

// ---------- State ----------
let players = [];               // {name, role}
let stats = {};                 // name -> {W,D,GF,GA,byeCount}
let qualifRound = 0;
let qualifMatches = [];         // {id, round, teamA[], teamB[], scoreA, scoreB, done}
let usedTeamPairs = {};         // track team pairs usage
let usedMatchups = {};          // track matchups usage
let qualifHistory = [];         // strings
let finals = null;              // {WB:{rounds:[]}, LB:{rounds:[]}, GF:[]}
let finalsHistory = [];        // strings

// ---------- Helpers ----------
const el = id => document.getElementById(id);
const randId = ()=> Math.random().toString(36).slice(2,9);
const shuffle = arr => arr.sort(()=>Math.random()-0.5);
const pairKey = (A,B) => { const t1 = A.slice().sort().join('&'); const t2 = B.slice().sort().join('&'); return [t1,t2].sort().join('|'); };
function ensurePlayer(n){ if(!stats[n]) stats[n] = {W:0,D:0,GF:0,GA:0,byeCount:0}; }

// ---------- UI render ----------
function renderPlayersList(){ el('playersList').innerHTML = players.length ? players.map(p=>`<span class="pill">${p.name} (${p.role})</span>`).join(' ') : '<span class="muted">Aucun joueur</span>'; }
function renderRanking(){
  const rows = Object.entries(stats).map(([name,s])=>({name, ...s}));
  rows.sort((a,b)=>{ if(b.W!==a.W) return b.W-a.W; const gda=a.GF-a.GA, gdb=b.GF-b.GA; if(gdb!==gda) return gdb-gda; return b.GF-a.GF; });
  let html = '<table><tr><th>Rang</th><th>Joueur</th><th>V</th><th>D</th><th>GF</th><th>GA</th><th>GD</th></tr>';
  rows.forEach((r,i)=> html+=`<tr><td>${i+1}</td><td>${r.name}</td><td>${r.W||0}</td><td>${r.D||0}</td><td>${r.GF||0}</td><td>${r.GA||0}</td><td>${(r.GF||0)-(r.GA||0)}</td></tr>`);
  html += '</table>'; el('ranking').innerHTML = html;
}

function renderQualifMatches(){
  const node = el('qualifMatches'); node.innerHTML = '';
  const current = qualifMatches.filter(m=>m.round===qualifRound);
  if(!current.length){ node.innerHTML = '<div class="muted">Aucun match généré pour cette manche.</div>'; return; }
  current.forEach((m,i)=>{
    const id = m.id;
    const d = document.createElement('div'); d.className='match';
    d.innerHTML = `<div><span class="badge">Qualif</span> <b>Match ${m.round}.${i+1}</b></div>
      <div>${m.teamA.join(' & ')} <b>vs</b> ${m.teamB.join(' & ')}</div>
      <div class="row"><input id="A_${id}" type="number" min="0" placeholder="0"> - <input id="B_${id}" type="number" min="0" placeholder="0">
      <button data-id="${id}">Valider</button></div>`;
    d.querySelector('button').onclick = ()=> submitQualif(id);
    node.appendChild(d);
  });
}
function renderQualifHistory(){ el('qualifHistory').innerHTML = qualifHistory.length ? '<ol>'+qualifHistory.map(s=>`<li>${s.replace(/\|/g,' vs ')}</li>`).join('')+'</ol>' : '<div class="muted">Aucun match.</div>'; }

function renderFinals(){
  const node = el('finalsArea'); node.innerHTML = '';
  if(!finals){ node.innerHTML = '<div class="muted">Phase finale non initialisée</div>'; el('debugFinals').textContent = 'finals not initialized'; return; }

  // Winners bracket
  finals.WB.rounds.forEach((rnd, ri)=>{
    const r = ri + 1;
    rnd.forEach((m, mi)=>{
      const uid = `W${r}_${m.id}`;
      const div = document.createElement('div'); div.className = 'match';
      div.innerHTML = `<div><span class="badge">[WB R${r} - Match ${mi+1}]</span> ${m.teamA.join(' & ')} vs ${m.teamB.join(' & ')}</div>`;
      const actions = document.createElement('div'); actions.className='row';
      if(!m.done){
        actions.innerHTML = `<input id="A_${uid}" type="number" min="0" placeholder="0"> - <input id="B_${uid}" type="number" min="0" placeholder="0"> <button>Valider</button>`;
        actions.querySelector('button').onclick = ()=> submitFinal(uid);
      } else {
        actions.innerHTML = `<div class="muted">Score: ${m.scoreA} - ${m.scoreB}</div>`;
      }
      div.appendChild(actions); node.appendChild(div);
    });
  });

  // Losers bracket
  finals.LB.rounds.forEach((rnd, ri)=>{
    const r = ri + 1;
    rnd.forEach((m, mi)=>{
      const uid = `L${r}_${m.id}`;
      const div = document.createElement('div'); div.className = 'match';
      div.innerHTML = `<div><span class="badge">[LB R${r} - Match ${mi+1}]</span> ${m.teamA.join(' & ')} vs ${m.teamB.join(' & ')}</div>`;
      const actions = document.createElement('div'); actions.className='row';
      if(!m.done){
        actions.innerHTML = `<input id="A_${uid}" type="number" min="0" placeholder="0"> - <input id="B_${uid}" type="number" min="0" placeholder="0"> <button style="background:#f59e0b">Valider</button>`;
        actions.querySelector('button').onclick = ()=> submitFinal(uid);
      } else {
        actions.innerHTML = `<div class="muted">Score: ${m.scoreA} - ${m.scoreB}</div>`;
      }
      div.appendChild(actions); node.appendChild(div);
    });
  });

  // Grand final(s)
  (finals.GF || []).forEach((m, idx)=>{
    const uid = `F${idx}_${m.id}`;
    const div = document.createElement('div'); div.className = 'match';
    div.innerHTML = `<div><span class="badge">[GF - Match ${idx+1}]</span> ${m.teamA.join(' & ')} vs ${m.teamB.join(' & ')}</div>`;
    const actions = document.createElement('div'); actions.className='row';
    if(!m.done){
      actions.innerHTML = `<input id="A_${uid}" type="number" min="0" placeholder="0"> - <input id="B_${uid}" type="number" min="0" placeholder="0"> <button>Valider</button>`;
      actions.querySelector('button').onclick = ()=> submitFinal(uid);
    } else {
      actions.innerHTML = `<div class="muted">Score: ${m.scoreA} - ${m.scoreB}</div>`;
    }
    div.appendChild(actions); node.appendChild(div);
  });

  el('debugFinals').textContent = JSON.stringify(finals, null, 2);
}
function renderFinalsHistory(){ el('finalsHistory').innerHTML = finalsHistory.length ? '<ol>'+finalsHistory.map(s=>`<li>${s.replace(/\|/g,' vs ')}</li>`).join('')+'</ol>' : '<div class="muted">Aucun match.</div>'; }

// ---------- Qualifs logic ----------
function incMatchup(teamA, teamB){ const k = teamA.slice().sort().join('&') + '|' + teamB.slice().sort().join('&'); usedMatchups[k] = (usedMatchups[k]||0) + 1; }
function incTeamPair(a,b){ const k = [a,b].slice().sort().join('&'); usedTeamPairs[k] = (usedTeamPairs[k]||0) + 1; }

function buildTeams(){
  const attackers = players.filter(p=>p.role==='Attaquant' || p.role==='Polyvalent').map(p=>p.name);
  const defenders = players.filter(p=>p.role==='Défenseur' || p.role==='Polyvalent').map(p=>p.name);
  let candidates = [];
  attackers.forEach(a => defenders.forEach(d => { if(a!==d) candidates.push({a,d,used: usedTeamPairs[[a,d].sort().join('&')]||0}); }));
  shuffle(candidates); candidates.sort((x,y) => x.used - y.used);
  const used = new Set(); const teams = [];
  candidates.forEach(c => { if(used.has(c.a) || used.has(c.d)) return; teams.push([c.a,c.d]); used.add(c.a); used.add(c.d); });
  const leftovers = players.map(p=>p.name).filter(n=>!used.has(n));
  while(leftovers.length >= 2) teams.push([leftovers.pop(), leftovers.pop()]);
  return teams;
}
function chooseBye(teams){
  if(!teams.length) return null;
  let best = Infinity, idx = 0;
  teams.forEach((t,i)=>{ const s = (stats[t[0]].byeCount||0) + (stats[t[1]].byeCount||0); if(s < best){ best = s; idx = i; } });
  return teams.splice(idx,1)[0];
}
function pairTeamsMinRepeats(teams){
  let best = null, bestScore = Infinity;
  for(let k=0;k<80;k++){
    const arr = teams.slice(); shuffle(arr);
    let score = 0, pairs = [];
    for(let i=0;i<arr.length;i+=2){
      const A = arr[i], B = arr[i+1];
      const key = A.slice().sort().join('&') + '|' + B.slice().sort().join('&');
      score += (usedMatchups[key]||0);
      pairs.push([A,B]);
    }
    if(score < bestScore){ bestScore = score; best = pairs; if(score === 0) break; }
  }
  return best;
}

function generateQualifRound(){
  if(players.length < 4) return alert('Au moins 4 joueurs requis');
  qualifRound++;
  el('roundInfo').textContent = 'Manche ' + qualifRound;
  const teams = buildTeams(); let copy = teams.slice();
  if(copy.length % 2 === 1){
    const bye = chooseBye(copy);
    stats[bye[0]].W++; stats[bye[1]].W++;
    stats[bye[0]].byeCount++; stats[bye[1]].byeCount++;
    qualifHistory.push(`${bye[0]} & ${bye[1]}|BYE`);
  }
  const pairs = pairTeamsMinRepeats(copy);
  pairs.forEach(pair=>{
    const [tA, tB] = pair;
    incTeamPair(tA[0], tA[1]); incTeamPair(tB[0], tB[1]);
    const id = 'Q' + randId();
    qualifMatches.push({ id, round: qualifRound, teamA: tA, teamB: tB, scoreA: null, scoreB: null, done:false });
  });
  renderQualifMatches(); renderRanking(); renderQualifHistory();
}

function submitQualif(id){
  const m = qualifMatches.find(x=>x.id===id); if(!m || m.done) return;
  const a = parseInt(el('A_'+id).value||'0',10), b = parseInt(el('B_'+id).value||'0',10);
  if(a<11 && b<11) return alert('Un score doit atteindre 11');
  m.scoreA = a; m.scoreB = b; m.done = true;
  const winner = a > b ? m.teamA : m.teamB;
  const loser = a > b ? m.teamB : m.teamA;
  winner.forEach(n => { ensurePlayer(n); stats[n].W++; stats[n].GF += Math.max(a,b); stats[n].GA += Math.min(a,b); });
  loser.forEach(n => { ensurePlayer(n); stats[n].D++; stats[n].GF += Math.min(a,b); stats[n].GA += Math.max(a,b); });
  incMatchup(m.teamA, m.teamB);
  qualifHistory.push(pairKey(m.teamA, m.teamB));
  renderQualifMatches(); renderRanking(); renderQualifHistory();
}

// ---------- Finals: double elimination and recomposition ----------
function startFinals(){
  const N = parseInt(el('finalCount').value, 10);
  const ranked = Object.entries(stats).map(([name,s])=>({name, ...s}))
    .sort((a,b)=>{ if(b.W!==a.W) return b.W-a.W; const gda=a.GF-a.GA, gdb=b.GF-b.GA; if(gdb!==gda) return gdb-gda; return b.GF-a.GF; });
  if(ranked.length < 4) return alert('Pas assez de joueurs qualifiés');
  let selected = ranked.slice(0, N).map(r=>r.name);
  if(selected.length % 2 !== 0) selected.pop(); // ensure even number
  const sh = shuffle(selected.slice());
  const teams = [];
  for(let i=0;i<sh.length;i+=2) teams.push([sh[i], sh[i+1]]);
  const teamCount = teams.length;
  if((teamCount & (teamCount-1)) !== 0) return alert("Le nombre d'équipes doit être une puissance de 2 (4,8,16...)");
  finals = { WB: { rounds: [] }, LB: { rounds: [] }, GF: [] };
  finals.WB.rounds.push( teamsToMatches(teams, 1, 'W') );
  renderFinals(); renderFinalsHistory();
  alert('Phase finale initialisée — validez tous les matchs WB R1 pour avancer');
}

function teamsToMatches(teamsArray, roundNum, type){
  const arr = [];
  for(let i=0;i<teamsArray.length;i+=2){
    const A = teamsArray[i], B = teamsArray[i+1];
    const key = pairKey(A,B);
    if(finalsHistory.includes(key) && i+2 < teamsArray.length){
      // try swap to avoid repeat
      const C = teamsArray[i+2]; teamsArray[i+1] = C; teamsArray[i+2] = B;
    }
    arr.push({ id: randId(), type, round: roundNum, teamA: A, teamB: B, scoreA: null, scoreB: null, done:false });
  }
  return arr;
}

function findFinalMatch(uid){
  if(!finals) return null;
  if(uid.startsWith('W')){
    const parts = uid.split('_'); const r = parseInt(parts[0].slice(1),10)-1; const id = parts[1];
    const arr = finals.WB.rounds[r] || []; return { match: arr.find(m=>m.id===id), bracket:'W', r };
  }
  if(uid.startsWith('L')){
    const parts = uid.split('_'); const r = parseInt(parts[0].slice(1),10)-1; const id = parts[1];
    const arr = finals.LB.rounds[r] || []; return { match: arr.find(m=>m.id===id), bracket:'L', r };
  }
  if(uid.startsWith('F')){
    const parts = uid.split('_'); const idx = parseInt(parts[0].slice(1),10);
    return { match: finals.GF[idx], bracket:'F', r: idx };
  }
  return null;
}

function submitFinal(uid){
  const meta = findFinalMatch(uid);
  if(!meta || !meta.match) return alert('Match introuvable');
  const m = meta.match; if(m.done) return;
  const a = parseInt(el('A_'+uid).value||'0',10), b = parseInt(el('B_'+uid).value||'0',10);
  if(a<11 && b<11) return alert('Un score doit atteindre 11');
  m.scoreA = a; m.scoreB = b; m.done = true;
  const winnerTeam = a > b ? m.teamA.slice() : m.teamB.slice();
  const loserTeam  = a > b ? m.teamB.slice() : m.teamA.slice();
  finalsHistory.push(pairKey(m.teamA, m.teamB));
  incMatchup(m.teamA, m.teamB);

  if(meta.bracket === 'W'){
    finals._pendingWB = finals._pendingWB || {};
    finals._pendingLB_fromWB = finals._pendingLB_fromWB || {};
    finals._pendingWB[meta.r] = finals._pendingWB[meta.r] || [];
    finals._pendingLB_fromWB[meta.r] = finals._pendingLB_fromWB[meta.r] || [];
    finals._pendingWB[meta.r].push(winnerTeam);
    finals._pendingLB_fromWB[meta.r].push(loserTeam);

    const allDone = finals.WB.rounds[meta.r].every(x=>x.done);
    if(allDone) handleWBRoundComplete(meta.r);
  }
  else if(meta.bracket === 'L'){
    finals._pendingLBWin = finals._pendingLBWin || {};
    finals._pendingLBWin[meta.r] = finals._pendingLBWin[meta.r] || [];
    finals._pendingLBWin[meta.r].push(winnerTeam);
    const arr = finals.LB.rounds[meta.r] || [];
    const allDone = arr.length>0 && arr.every(x=>x.done);
    if(allDone) handleLBRoundComplete(meta.r);
  }
  else if(meta.bracket === 'F'){
    const idx = meta.r;
    if(idx === 0){
      const lbWon = winnerTeam.join(',') === m.teamB.join(',');
      if(lbWon){
        // reset final
        finals.GF.push({ id: randId(), type:'F', round:2, teamA: m.teamB, teamB: m.teamA, scoreA: null, scoreB: null, done:false });
        alert('LB gagne la première finale — une seconde finale est ajoutée.');
      } else {
        alert('Vainqueur du tournoi : ' + winnerTeam.join(' & '));
      }
    } else {
      alert('Vainqueur du tournoi : ' + winnerTeam.join(' & '));
    }
  }

  maybeCreateGrandFinal();
  renderFinals();
  renderFinalsHistory();
}

function handleWBRoundComplete(roundIdx){
  const winners = finals._pendingWB[roundIdx] ? finals._pendingWB[roundIdx].slice() : [];
  finals._pendingWB[roundIdx] = [];
  const nextTeams = [];
  for(let i=0;i<winners.length;i+=2){
    const t1 = winners[i], t2 = winners[i+1];
    if(!t1 || !t2) continue;
    // recomposition: teamC = [t1[0], t2[0]] ; teamD = [t1[1], t2[1]]
    nextTeams.push([t1[0], t2[0]]);
    nextTeams.push([t1[1], t2[1]]);
  }
  if(nextTeams.length){
    finals.WB.rounds[roundIdx+1] = finals.WB.rounds[roundIdx+1] || [];
    finals.WB.rounds[roundIdx+1] = finals.WB.rounds[roundIdx+1].concat( teamsToMatches(nextTeams, roundIdx+2, 'W') );
  }
  // send losers to LB round 1
  const losers = finals._pendingLB_fromWB[roundIdx] ? finals._pendingLB_fromWB[roundIdx].slice() : [];
  finals._pendingLB_fromWB[roundIdx] = [];
  if(losers.length){
    finals.LB.rounds[0] = finals.LB.rounds[0] || [];
    for(let i=0;i<losers.length;i+=2){
      const aT = losers[i], bT = losers[i+1];
      if(aT && bT) finals.LB.rounds[0].push({ id: randId(), type:'L', round:1, teamA:aT, teamB:bT, scoreA:null, scoreB:null, done:false });
    }
  }
}

function handleLBRoundComplete(roundIdx){
  const wins = finals._pendingLBWin[roundIdx] ? finals._pendingLBWin[roundIdx].slice() : [];
  finals._pendingLBWin[roundIdx] = [];
  const nextTeams = [];
  for(let i=0;i<wins.length;i+=2){
    const t1 = wins[i], t2 = wins[i+1];
    if(!t1 || !t2) continue;
    nextTeams.push([t1[0], t2[0]]);
    nextTeams.push([t1[1], t2[1]]);
  }
  if(nextTeams.length){
    finals.LB.rounds[roundIdx+1] = finals.LB.rounds[roundIdx+1] || [];
    finals.LB.rounds[roundIdx+1] = finals.LB.rounds[roundIdx+1].concat( teamsToMatches(nextTeams, roundIdx+2, 'L') );
  }
}

function maybeCreateGrandFinal(){
  if(!finals) return;
  let wbChampion = null;
  for(let r = finals.WB.rounds.length-1; r>=0; r--){
    const rnd = finals.WB.rounds[r] || [];
    if(rnd.length === 1 && rnd[0].done){ wbChampion = rnd[0].scoreA > rnd[0].scoreB ? rnd[0].teamA : rnd[0].teamB; break; }
  }
  let lbChampion = null;
  for(let r = finals.LB.rounds.length-1; r>=0; r--){
    const rnd = finals.LB.rounds[r] || [];
    if(rnd.length === 1 && rnd[0].done){ lbChampion = rnd[0].scoreA > rnd[0].scoreB ? rnd[0].teamA : rnd[0].teamB; break; }
  }
  if(wbChampion && lbChampion && (!finals.GF || finals.GF.length === 0)){
    finals.GF = [{ id: randId(), type:'F', round:1, teamA: wbChampion, teamB: lbChampion, scoreA:null, scoreB:null, done:false }];
  }
}

// Force advancement if UI stuck
function forceAdvance(){
  if(!finals) return alert('Phase finale non initialisée');
  for(let r=0; r<finals.WB.rounds.length; r++){
    const arr = finals.WB.rounds[r] || [];
    if(arr.length>0 && arr.every(x=>x.done)) handleWBRoundComplete(r);
  }
  for(let r=0; r<finals.LB.rounds.length; r++){
    const arr = finals.LB.rounds[r] || [];
    if(arr.length>0 && arr.every(x=>x.done)) handleLBRoundComplete(r);
  }
  maybeCreateGrandFinal();
  renderFinals();
  renderFinalsHistory();
}

// Export history as text file
function exportHistory(){
  const all = ['--- Qualifications ---'].concat(qualifHistory).concat(['','--- Finales ---']).concat(finalsHistory);
  const blob = new Blob([all.join('\n')], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'tournoi_history.txt'; a.click();
  URL.revokeObjectURL(url);
}

// ---------- Init & bindings ----------
document.addEventListener('DOMContentLoaded', ()=>{
  el('btnAdd').onclick = ()=>{
    const name = el('playerName').value.trim();
    const role = el('playerRole').value;
    if(!name) return alert('Nom requis');
    if(players.some(p=>p.name.toLowerCase() === name.toLowerCase())) return alert('Nom déjà inscrit');
    players.push({name, role});
    ensurePlayer(name);
    el('playerName').value = '';
    renderPlayersList(); renderRanking();
  };

  el('btnReset').onclick = ()=> {
    if(!confirm('Réinitialiser tout le tournoi ?')) return;
    players = []; stats = {}; qualifRound = 0; qualifMatches = []; usedTeamPairs = {}; usedMatchups = {}; qualifHistory = []; finals = null; finalsHistory = [];
    renderPlayersList(); renderQualifMatches(); renderRanking(); renderFinals(); renderQualifHistory(); renderFinalsHistory();
    el('roundInfo').textContent = ''; el('debugFinals').textContent = '--';
  };

  el('btnNewRound').onclick = generateQualifRound;
  el('btnStartFinals').onclick = startFinals;
  el('btnForceNext').onclick = forceAdvance;
  el('btnExport').onclick = exportHistory;

  // initial render
  renderPlayersList(); renderQualifMatches(); renderRanking(); renderFinals(); renderQualifHistory(); renderFinalsHistory();
});
</script>
</body>
</html>
